<!DOCTYPE HTML>
<!--
	   Massively by HTML5 UP
	   html5up.net | @ajlkn
	   Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
   -->
<html>
	  <head>
		    <title>What Is A Dynamic Array And How To Implement One In C - shnupta</title>
		    <meta charset="utf-8" />
		    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		    <link rel="stylesheet" href="../../../assets/css/main.css" />
		    <noscript><link rel="stylesheet" href="../../../assets/css/noscript.css" /></noscript>
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/manifest.json">
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="theme-color" content="#ffffff">
	  </head>
	  <body class="is-loading">

		    <!-- Wrapper -->
			  <div id="wrapper">

				    <!-- Header -->
					  <header id="header">
						    <a href="../../../index.html" class="logo">shnupta</a>
					  </header>

				    <!-- Nav -->
					  <nav id="nav">
						    <ul class="links">
							      <li class="active"><a href="../../../index.html">Home</a></li>
							      <li><a href="../../../aboutme.html">About Me</a></li>
							      <li><a href="../../../projects.html">Projects</a></li>
						    </ul>
						    <ul class="icons">
							      <li><a target="_blank" href="https://twitter.com/casey__williams" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
							      <li><a target="_blank" href="https://www.facebook.com/williamshoops96" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
							      <li><a target="_blank" href="https://www.instagram.com/williamshoops96" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
							      <li><a target="_blank" href="https://github.com/shnupta" class="icon fa-github"><span class="label">GitHub</span></a></li>

                    <li><a target="_blank" href="https://linkedin.com/in/casey-williams/" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li>
						    </ul>
					  </nav>

				    <!-- Main -->
					  <div id="main">

						    <!-- Post -->
							  <section class="post">
								    <header class="major">
									      <span class="date">26 August, 2017</span>
									      <h1>What Is A Dynamic Array And How To Implement One In C</h1>
									      <p>This guide has been written as a complete introduction to dynamic arrays, with<br>
comparisons against similar array types like dynamically allocated and<br>
fixed-size arrays, and also a tutorial on how to implement one in C.</p>
								    </header>
								   <p><a href="https://github.com/shnupta/practice-c/tree/master/darray">Link to the repository of code.</a></p>
</blockquote>
<p>Prerequisites: you should have a basic understanding of pointers and some
knowledge of programming in C.</p>
<p>Let’s get to it!</p>
<h3><a id="First_lets_define_an_array_14"></a>First let’s define an array.</h3>
<p>An array is a contiguous area of memory, consisting of equally sized elements,
indexed by contiguous integers.</p>
<p>Typically, an array has a fixed size when declared in most languages.</p>
<pre><code>int my_array[10]; // declares an array of integers with capacity 10
</code></pre>
<p>A fixed-size array means that once the array has been declared with its size, it
cannot then be changed. The standard array in C is a fixed size array. However,
a fixed size array (static) can present some problems, we must provide the size
of the array at compile time. There is a way round this by using
dynamically-allocated arrays. Dynamically-allocated arrays can specify the size
of the array in run time. Something like this:</p>
<pre><code>int *my_array = new int[size];
</code></pre>
<p>But the problem that still resides is: what if we don’t know the maximum size of
the array when we allocate it?</p>
<p>This is where dynamic arrays come in.</p>
<h3><a id="Dynamic_Arrays_37"></a>Dynamic Arrays</h3>
<p>The idea of a dynamic array is to have a pointer to a dynamically-allocated
array (see above), and then when the size of the array becomes bigger than what
was allocated, we create a new dynamically-allocated array, with a larger size,
and then reset our pointer to that. We can also call a dynamic array an
automatically resizing array.</p>
<h4><a id="What_should_it_be_able_to_do_45"></a>What should it be able to do?</h4>
<p>Typically a dynamic array should be able to:</p>
<ul>
<li>Get(<strong>i</strong>): return the element at position **i **— O(1)</li>
<li>Set(<strong>i</strong>, <strong>val</strong>): set the element at position **i **to the value <strong>val</strong></li>
<li>Push(<strong>val</strong>): add <strong>val</strong> to the end of the array — typically O(1) but can<br>
differ (see later)</li>
<li>Remove(<strong>i</strong>): remove the element at position <strong>i</strong> — O(n)</li>
<li>Size(): return the number of elements in the array</li>
</ul>
<h3><a id="The_Implementation_56"></a>The Implementation</h3>
<p>The files we will have for the implementation of the dynamic array are:</p>
<ul>
<li>darray.h — header file containing the struct definition and function
declarations</li>
<li>darray.c — the source code for the functions</li>
</ul>
<p>Our <em>darray.h</em> file will look like
<a href="https://github.com/shnupta/practice-c/blob/master/darray/darray.h">this</a>.</p>
<p>First of all we need to declare our array structure:</p>
<pre><code>typedef struct darray {
    void **items;
    int size;
    int capacity;
} darray;
</code></pre>
<p>is our ‘dynamically-allocated’ array.  is pretty self explanatory and  is the
maximum elements that  can hold at the current time.</p>
<p>We are going to have 15 functions for our <em>darray</em>.</p>
<pre><code>void darray_init(darray *);
void darray_init_with_cap(darray *, int);
void darray_destroy(darray *);
int darray_size(darray *);
int darray_capacity(darray *);
int darray_is_empty(darray *);
void* darray_at(darray *, int);
void darray_push(darray *, void *);
void darray_insert(darray *, int, void *);
void darray_prepend(darray *, void *);
void *darray_pop(darray*);
void darray_delete(darray*, int);
void darray_remove(darray*, void *);
int darray_find(darray*, void *);
void darray_resize(darray*, int);
</code></pre>
<p>*darray_init *will be our allocation function. Here the array will be created
and the memory for it will be allocated.</p>
<pre><code>void darray_init(darray *vec) {
    vec-&gt;capacity = DARRAY_INIT_CAPACITY;
    vec-&gt;size = 0;
    vec-&gt;items = malloc(sizeof(void *) * vec-&gt;capacity);
}
</code></pre>
<p>First of all, we set the capacity of the vector to our initialisation capacity
(which in this case is 16). Then we set the size to zero as our array contains
no elements and finally we use* <strong><em>malloc()</em></strong> *to allocate some memory for our
items array. The <strong>malloc</strong>() function allocates the provided number of bytes of
memory and returns a pointer to the allocated memory. Now we have some memory to
play around with and use to store our data.</p>
<p>The *darray_init_with_cap *is an optional function that I wrote to allow for a
bit more freedom. You just pass in the capacity size rather than using the
standard macro.</p>
<p>Before we continue, we also need a way to clear up our *darray *when we are
finished with it — we don’t want any memory leaks! Our *darray_destroy *function
simply uses **free() **to deallocate the memory we allocated for *items *and
sets the <em>size</em> and <em>capacity</em> to NULL;</p>
<p>The next few functions in the header file are pretty self explanatory. Return
the size, capacity or 1 if the size is zero. You get the idea.</p>
<p>Now for some more interesting functions…</p>
<p>Obviously we need to access the elements inside our array, but we must do this
at O(1) runtime. This is what makes an array special.</p>
<p>Remember our array is indexed by a range of contiguous integers so we can use
this to access the element. Accessing an element is fairly straight forward. We
need the memory address of where our elements start, the size of each element
(in this case it’s the size of a void pointer) and the index that we want to
access.</p>
<pre><code>void* darray_at(darray *vec, int index) {
    assert(index &lt; vec-&gt;size &amp;&amp; index &gt;= 0);
    return *(vec-&gt;items + sizeof(void *) * index);
}
</code></pre>
<p>The assert statement I’m using is just checking that the index we are trying to
access actually exists in our array, if it doesn’t we don’t want to let the
program continue as it could end up badly. To access the element we take the
address of our array  and then add to that the number of bytes until the element
that we want to access. We do this by using the **sizeof() **function which
returns the size in bytes of the argument we pass in, and we then times this by
our index as that is how many bytes until our element begins. We then
dereference this memory address which returns our void * element inside our
array!</p>
<p>What about adding elements? One of the simplest ways to add an element to a
dynamic array is to push to the end of the array.</p>
<pre><code>void darray_push(darray *vec, void *item) {
    if (vec-&gt;size == vec-&gt;capacity) {
        darray_resize(vec, vec-&gt;capacity * 2);
    }
    *(vec-&gt;items + sizeof(void *) * vec-&gt;size) = item;
    vec-&gt;size++;
}
</code></pre>
<p>We will get to the resizing of our array at the end of the tutorial. Here we are
setting the item at the pointer location that is the index of <em>size</em> equal to
the value of our pointer. Because we are using zero-based indexing, the element
at position *size *is the next element at the end of our array. Finally we
increment the size of the array.</p>
<p>It’s all well and good slapping a value on the end, but sometimes we want to
slot an item into the middle of the array and keep all of our other elements.
Here is where inserting comes in.</p>
<pre><code>void darray_insert(darray *vec, int index, void *item) {
    assert(index &gt; 0 &amp;&amp; index &lt; vec-&gt;size);
    if(vec-&gt;size == vec-&gt;capacity) {
        darray_resize(vec, vec-&gt;capacity * 2);
    }
    for (int i = vec-&gt;size - 1; i &gt;= index; i--) {
        *(vec-&gt;items + sizeof(void *) * (i + 1)) = *(vec-&gt;items +        sizeof(void *) * i);
    }
    *(vec-&gt;items + sizeof(void *) * index) = item;
    vec-&gt;size++;
}
</code></pre>
<p>Once again we use the **assert() **statement to check the passed in <em>index</em> is<br>
valid and also check if the array needs to be resized. Before we can actually<br>
insert our value into the <em>index</em>, we need to make space for it. We cannot<br>
simply change the value at the <em>index</em> as we’d be overwriting the existing<br>
value. So what we do is loop from the last value of our array until we reach the<br>
<em>index</em> we want to insert at, and copy that value to the index that is one<br>
greater than it. We cannot loop from the <em>index</em> towards the end of the array as<br>
we would just be copying the same value across each time. Once we’ve made the<br>
space we set the value at the memory address of our <em>index</em>, like before. And<br>
again we increment the size of the array.</p>
<p>The  function simply uses the  function and passes zero as the index argument.</p>
<pre><code>void* darray_pop(darray *vec) {
    assert(vec-&gt;size &gt; 0);
    if(vec-&gt;size &lt;= vec-&gt;capacity / 4) {
        darray_resize(vec, vec-&gt;capacity / 2);
    }
    void *ret_val = *(vec-&gt;items + sizeof(void *) * (vec-&gt;size-1));
 
    *(vec-&gt;items + sizeof(void *) * (vec-&gt;size-1)) = NULL;
    vec-&gt;size--;

    return ret_val;
}
</code></pre>
<p>Popping a value is deleting the last value from our array, and returning it. At<br>
the beginning we do the normal validation check and resize check. Then we create<br>
the  variable. This is a copy of the last element of our array (we need this to<br>
be able to return the element after we delete it). Then we simply set the value<br>
to be  at the address of the last element (which is  due to zero-based<br>
indexing). Don’t forget to decrement the <em>size</em> of our array as we’ve deleted an<br>
element.</p>
<pre><code>void darray_delete(darray *vec, int index) {
    assert(index &gt; 0 &amp;&amp; index &lt; vec-&gt;size);
    if(vec-&gt;size &lt;= vec-&gt;capacity / 4) {
        
        darray_resize(vec, vec-&gt;capacity / 2);
    }
    *(vec-&gt;items + sizeof(void *) * index) = NULL;
    for (int i = index; i &lt; vec-&gt;size; i++) {
        *(vec-&gt;items + sizeof(void *) * i) = *(vec-&gt;items + sizeof(void *) * (i+1));
    }
    vec-&gt;size--;}
</code></pre>
<p>Deleting an element in our array is similar to inserting. Only rather then<br>
shifting elements to the right before we insert, we shift elements left after<br>
deleting the item.</p>
<pre><code>void darray_remove(darray *vec, void *item) {
    for(int i = 0; i &lt; vec-&gt;size; i++) {
        if (*(vec-&gt;items + sizeof(void *) * i) == item) {
            darray_delete(vec, i);
        }
    }
}
</code></pre>
<p>Our remove function looks for any elements that have the value of *item *and<br>
removes them from our array using the previous function. N.B. this will delete<br>
multiple occurrences and not just the first match.</p>
<pre><code>int darray_find(darray *vec, void *item) {
    for(int i = 0; i &lt; vec-&gt;size; i++) {
        if (*(vec-&gt;items + sizeof(void *) * i) == item) {
            return i;
         }
    }
    return -1;
}
</code></pre>
<p>Our find function is very similar to our remove function. However on the first<br>
occurrence of <em>item</em> it will return the index that it is at. If a match is not<br>
found, -1 is returned.</p>
<p>Now onto the most important function of them all!</p>
<pre><code>void darray_resize(darray *vec, int new_size) {
    assert(new_size &gt; 0);
    vec-&gt;capacity = new_size;
    void **new_items = malloc(sizeof(void *) * vec-&gt;capacity);
    new_items = vec-&gt;items;
    free(vec-&gt;items);
    vec-&gt;items = new_items;
}
</code></pre>
<p>We have called this function multiple times (when deleting, inserting). First of<br>
all we check the new size is valid. Then we change our array’s capacity property<br>
to be the new size. After we allocate memory in a similar way to how we<br>
initialised the array, this time with the new capacity. We then copy our<br>
existing elements to our newly allocated memory, afterwards freeing the previous<br>
array memory. Finally we set our array’s items collection to be the newly<br>
allocated and assigned memory.</p>
<hr>
<p>Well that’s it! I hope you found this a bit of a no-nonsense, straight to the<br>
point way of learning and got something from it. If you have any questions or<br>
need any help, feel free to drop me an email.</p>

									      <div id="disqus_thread"></div>
										    <script>
						             
						             
										     //      FIX BELOW!!!!
						             
										     /**
										      *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
										      *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
						             
										     var disqus_config = function () {
										         this.page.url = "https://shnupta.github.io/blog/17/08/darray.html";  // Replace PAGE_URL with your page's canonical URL variable
										         this.page.identifier = "17/08/darray"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
										     };
						             
										     (function() { // DON'T EDIT BELOW THIS LINE
										         var d = document, s = d.createElement('script');
										         s.src = 'https://shnupta.disqus.com/embed.js';
										         s.setAttribute('data-timestamp', +new Date());
										         (d.head || d.body).appendChild(s);
										     })();
										    </script>
										    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
							          
						</div>
						<script id="dsq-count-scr" src="//shnupta.disqus.com/count.js" async></script>
					  
								 
							  </section>

				</div>

				<!-- Footer -->
				<footer id="footer">
						<section class="split contact">
							  <section class="alt">
								    <h3>Area</h3>
								    <p>Somerset</p>
							  </section>
						    <section>
								    <h3>Phone</h3>
								    <p>07477895503</p>
							  </section>
							  <section>
								    <h3>Email</h3>
								    <p><a href="mailto:williamshoops96@gmail.com">williamshoops96@gmail.com</a></p>
							  </section>
                <section>
	              <h3>Social</h3>
								    <ul class="icons alt">
										    <li><a target="_blank" href="https://twitter.com/casey__williams" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
										    <li><a target="_blank" href="https://www.facebook.com/williamshoops96" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
										    <li><a target="_blank" href="https://www.instagram.com/williamshoops96" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
										    <li><a target="_blank" href="https://github.com/shnupta" class="icon fa-github"><span class="label">GitHub</span></a></li>

                    <li><a target="_blank" href="https://linkedin.com/in/casey-williams/" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li>
								    </ul>
							  </section>
						</section>
				</footer>

				<!-- Copyright -->
				<div id="copyright">
						<ul><li>&copy; Casey Williams</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
				</div>

			  </div>

		    <!-- Scripts -->
			  <script src="../../../assets/js/jquery.min.js"></script>
			  <script src="../../../assets/js/jquery.scrollex.min.js"></script>
			  <script src="../../../assets/js/jquery.scrolly.min.js"></script>
			<script src="../../../assets/js/skel.min.js"></script>
			<script src="../../../assets/js/util.js"></script>
			<script src="../../../assets/js/main.js"></script>

	</body>
</html>
